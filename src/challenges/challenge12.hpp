#pragma once

#include <map>

#include "challenge_interface.hpp"

/*
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
 * ten terms would be:
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * Let us list the factors of the first seven triangle numbers:
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,
 * 10: 1,2,5,1
 * 15: 1,3,5,1
 * 21: 1,3,7,2
 * 28: 1,2,4,7,14,28
 * We can see that 28 is the first triangle number to have over five divisors.
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 */

namespace euler {
class Challenge12 : public BaseChallenge<12> {
 public:
  bool run() const override;

 private:
  static int findSmallestPrime(const int num);
  static std::map<int, int> getFactors(int num);
  static int getNDivisors(int num);
  static int findTriangleWithNDivisors(const int nDivisors);
};

int Challenge12::findSmallestPrime(const int num) {
  if (num % 2 == 0) return 2;
  for (int i = 3; i * i <= num; i += 2)
    if (num % i == 0) return i;
  return num;
}

std::map<int, int> Challenge12::getFactors(int num) {
  std::map<int, int> factors{};
  int factor = 1;
  while (factor != num) {
    num /= factor;
    factor = findSmallestPrime(num);
    auto it = factors.find(factor);
    if (it == factors.end())  // New element
      factors.insert(std::pair<int, int>(factor, 1));
    else  // Update to a larger value
      it->second++;
  }
  return factors;
}

int Challenge12::getNDivisors(int num) {
  auto factors = getFactors(num);
  auto nDivisors = 1;
  for (auto [divisor, reps] : factors) nDivisors *= (reps + 1);
  return nDivisors;
}

int Challenge12::findTriangleWithNDivisors(const int nDivisors) {
  auto num = 1, ctr = 1;
  while (getNDivisors(num) < nDivisors) {
    ctr++;
    num += ctr;
  }
  return num;
}

bool Challenge12::run() const {
  return findTriangleWithNDivisors(500) == 76576500;
}

}  // namespace euler
